"""Base classes for dynamics inference."""

from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Union
import jax.numpy as jnp
import numpy as np
from sklearn.base import BaseEstimator
from pathlib import Path
import pickle

from ..config.schemas import InferenceConfig


class BaseInference(ABC):
    """
    A base class for inference tasks, providing shared utilities and requiring specific methods
    to be implemented by subclasses.
    """

    def __init__(self, config: InferenceConfig):
        self.config = config
        self.models = []
        self.fitted = False

    @abstractmethod
    def fit(self, x: jnp.ndarray, t: Optional[jnp.ndarray] = None, **kwargs) -> "BaseInference":
        """
        Fit the model to the trajectory data.

        Parameters
        ----------
        x : jnp.ndarray
            Trajectory data of shape (T, N, D) where T is time, N is particles, D is dimensions
        t : jnp.ndarray, optional
            Time points of shape (T,)
        **kwargs : additional fitting parameters

        Returns
        -------
        self : fitted inference model
        """
        pass

    @abstractmethod
    def predict(self, x: jnp.ndarray, **kwargs) -> jnp.ndarray:
        """
        Predict derivatives using the trained model.

        Parameters
        ----------
        x : jnp.ndarray
            Input trajectory data

        Returns
        -------
        x_dot : jnp.ndarray
            Predicted derivatives
        """
        pass

    @abstractmethod
    def get_feature_names(self) -> List[str]:
        """
        Get the names of the features generated by the model.

        Returns
        -------
        feature_names : list of str
            The names of the features.
        """
        pass

    def save_model(self, path: Union[str, Path]) -> None:
        """Save the trained model to disk."""
        path = Path(path)
        path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(path, 'wb') as f:
            pickle.dump(self, f)

    @classmethod
    def load_model(cls, path: Union[str, Path]) -> "BaseInference":
        """Load a trained model from disk."""
        with open(path, 'rb') as f:
            return pickle.load(f)

    def get_model_info(self) -> Dict[str, Any]:
        """Get information about the trained model."""
        return {
            "fitted": self.fitted,
            "model_type": self.__class__.__name__,
            "config": self.config.to_dict() if hasattr(self.config, 'to_dict') else str(self.config),
        }


class DynamicsInferrer(BaseInference):
    """
    Base class for dynamics inference methods that learn differential equations.
    """

    def __init__(self, config: InferenceConfig):
        super().__init__(config)
        self.learned_equations = None
        
    @abstractmethod
    def get_equations(self, symbolic: bool = True) -> Union[List[str], List[Any]]:
        """
        Get the learned differential equations.
        
        Parameters
        ----------
        symbolic : bool
            Whether to return symbolic expressions or string representations
            
        Returns
        -------
        equations : list
            Learned differential equations
        """
        pass
        
    @abstractmethod
    def simulate(self, x0: jnp.ndarray, t: jnp.ndarray, **kwargs) -> jnp.ndarray:
        """
        Simulate the learned dynamics forward in time.
        
        Parameters
        ----------
        x0 : jnp.ndarray
            Initial condition
        t : jnp.ndarray  
            Time points to simulate
        **kwargs : additional simulation parameters
            
        Returns
        -------
        trajectory : jnp.ndarray
            Simulated trajectory
        """
        pass

    def print_equations(self, precision: int = 3) -> None:
        """Print the learned equations in a readable format."""
        equations = self.get_equations(symbolic=True)
        print("Learned Dynamics Equations:")
        print("=" * 40)
        for i, eq in enumerate(equations):
            print(f"Component {i}: {eq}")
        print("=" * 40)

    def save_equations(self, path: Union[str, Path], format: str = "latex") -> None:
        """
        Save the learned equations to a file.
        
        Parameters
        ----------
        path : Union[str, Path]
            Path to save the equations
        format : str
            Format to save in ('latex', 'text', 'sympy')
        """
        path = Path(path)
        path.parent.mkdir(parents=True, exist_ok=True)
        
        equations = self.get_equations(symbolic=True)
        
        with open(path, 'w') as f:
            if format == "latex":
                f.write("% Learned Dynamics Equations\n")
                f.write("\\begin{align}\n")
                for i, eq in enumerate(equations):
                    f.write(f"\\dot{{x}}_{{{i}}} &= {eq} \\\\\n")
                f.write("\\end{align}\n")
            elif format == "text":
                f.write("Learned Dynamics Equations\n")
                f.write("=" * 40 + "\n")
                for i, eq in enumerate(equations):
                    f.write(f"dx_{i}/dt = {eq}\n")
            else:  # sympy format
                for i, eq in enumerate(equations):
                    f.write(f"eq_{i} = {repr(eq)}\n")